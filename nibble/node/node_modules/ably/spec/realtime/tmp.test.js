"use strict";

define(['ably', 'shared_helper', 'async'], function(Ably, helper, async) {
	var currentTime, exports = {},
		_exports = {},
		utils = helper.Utils,
		displayError = helper.displayError,
		closeAndFinish = helper.closeAndFinish,
		monitorConnection = helper.monitorConnection,
		testOnAllTransports = helper.testOnAllTransports,
		mixin = helper.Utils.mixin;

	exports.setupauth = function(test) {
		test.expect(1);
		helper.setupApp(function(err) {
			if(err) {
				test.ok(false, helper.displayError(err));
				test.done();
				return;
			}

			var rest = helper.AblyRest();
			rest.time(function(err, time) {
				if(err) {
					test.ok(false, helper.displayError(err));
				} else {
					currentTime = time;
					test.ok(true, 'Obtained time via REST');
				}
				test.done();
			});
		});
	};


	testOnAllTransports(exports, 'publishQueued', function(realtimeOpts) { return function(test) {
		test.expect(150);
		var realtime;
		try {
			realtime = helper.AblyRealtime(utils.mixin(realtimeOpts, { autoConnect: false, log: {level: 4} }));
			var channel = realtime.channels.get('publishQueued_' + String(Math.random()).substr(2));

			async.parallel([
				function(cb) {
					var expectedMsgNum = 0;
					channel.subscribe('event', function(msg) {
						var num = msg.data.num;
						test.ok(true, 'Received event ' + num);
						test.equal(expectedMsgNum, num, 'Event ' + num + ' was in the right order');
						expectedMsgNum++;
						if(num === 49) cb();
					});
				},
				function(cb) {
					var ackd = 0;
					var publish = function(i) {
						channel.publish('event', {num: i}, function(err) {
							test.ok(!err, 'successfully published ' + i + (err ? ' err was ' + displayError(err) : ''));
							ackd++;
							if(ackd === 50) cb();
						});
						if(i < 49) {
							setTimeout(function() {
								publish(i + 1);
							}, 20);
						}
					};
					publish(0);
				},
				function(cb) {
					realtime.connection.on('connected', function() { cb(); });
					realtime.connection.connect();
				}
			], function() {
				closeAndFinish(test, realtime);
			});
			monitorConnection(test, realtime);
		} catch(e) {
			test.ok(false, 'test failed with exception: ' + e.stack);
			closeAndFinish(test, realtime);
		}
	};});



	return module.exports = helper.withTimeout(exports);
});
